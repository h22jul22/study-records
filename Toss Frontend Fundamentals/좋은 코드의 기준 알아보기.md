토스에서 좋은 프론트엔드 코드의 기준에 대해서 소개하는 [Frontend Fundamentals](https://frontend-fundamentals.com/)가 오픈 소스로 공개되었다.

> 이런 분들에게 추천해요
>
> -   🦨 코드에 대해서 고민되는데 **논리적으로 설명하기 어려운 개발자**
> -   👀 **나쁜 코드를 빠르게 감지**하고 개선하는 방법을 공부하고 싶은 개발자
> -   🤓 코드 리뷰 등에서 누가 전달해준 링크를 타고 들어와 "내 코드가 이랬구나"를 **객관적 시각으로 인지**하게 될 개발자
> -   👥 **팀과 함께** 공통의 코딩 스타일과 코드 품질의 기준을 세워보고 싶은 개발자

나는 그저 아직 학습중인 예비 프론트엔드 개발자로서, 나에게는 좋은 프론트엔드 코드는 어떤건지에 대한 몇가지의 방향성에 대해 고민할 수 있게 기준을 정리해주는 가이드가 될 것 같아 너무나도 감사한 정보 공유이다.

물론 지금 모든 내용을 다 이해하고 반영할 수 있는 부분인지는 모르겠지만, 내용을 살펴보면서 학습하고 기록하고자 한다. 앞으로 코드를 작성하고 리팩토링하면서 어떤 기준으로 좋은 코드를 위해 고민했는가에 대한 가이드가 되지 않을까싶다.

정리한 내용은 평소 생각해보지 못했던 부분이나, 새롭게 알게된 내용 등을 위주로 작성하였다.

> 🗣️ "좋은 프론트엔드 코드는 **변경하기 쉬운** 코드예요."

좋은 코드란 변경하기 쉬운 코드이다. 즉 좋은 코드를 위한 설명으로 변경하기 쉬운 코드에 대한 전략을 소개하고 있다.

그렇다면 어떤 코드가 변경하기 쉬운가?

코드가 변경하기 쉬운지는 4가지 기준(가독성, 예측가능성, 응집도, 결합도)으로 판단할 수 있다.

## 1. 가독성

### 1-1. 같이 실행되지 않는 코드 분리하기

동시에 실행되지 않는 코드가 하나의 함수 또는 컴포넌트에 있으면 코드를 읽는 사람이 한 번에 고려해야 하는 맥락이 많고, 동시에 실행되지 않는 코드가 교차되어서 나타나서 코드를 이해할 때 부담을 준다.

📝 **코드 예시**

-   사용자의 권한이 보기 전용(`"viewer"`)이면, 초대 버튼은 비활성화되어 있고, 애니메이션도 재생하지 않아요.
-   사용자가 일반 사용자이면, 초대 버튼을 사용할 수 있고, 애니메이션도 재생해요.

```jsx
function SubmitButton() {
    const isViewer = useRole() === 'viewer';

    useEffect(() => {
        if (isViewer) {
            return;
        }
        showButtonAnimation();
    }, [isViewer]);

    return isViewer ? (
        <TextButton disabled>Submit</TextButton>
    ) : (
        <Button type='submit'>Submit</Button>
    );
}
```

나는 예시 코드를 보고 어떤 점이 문제인지 인지하지 못했다..
왜냐하면 나는 이렇게 코드를 짜왔기 때문이다. 😂

✏️ **개선해보기**

-   `<SubmitButton />` 코드 곳곳에 있던 분기가 단 하나로 합쳐지면서, 분기가 줄어들었어요.
-   `<ViewerSubmitButton />`과 `<AdminSubmitButton />` 에서는 하나의 분기만 관리하기 때문에, 코드를 읽는 사람이 한 번에 고려해야 할 맥락이 적어요.

```jsx
function SubmitButton() {
    const isViewer = useRole() === 'viewer';

    return isViewer ? <ViewerSubmitButton /> : <AdminSubmitButton />;
}

function ViewerSubmitButton() {
    return <TextButton disabled>Submit</TextButton>;
}

function AdminSubmitButton() {
    useEffect(() => {
        showAnimation();
    }, []);

    return <Button type='submit'>Submit</Button>;
}
```

💡 **변경하기 쉬운 코드 === 코드를 읽는 사람이 한 번에 고려해야 하는 맥락이 적은 것**

때문에 같이 실행되지 않는 코드는 분리하여 분기를 줄이고, 어떤 역할을 하는지 이해하기 쉽게 맥락을 줄여보자.

<br>

### 1-2. 구현 상세 추상화하기

한 사람이 코드를 읽을 때 동시에 고려할 수 있는 총 맥락의 숫자는 제한되어 있다고 한다. 내 코드를 읽는 사람들이 코드를 쉽게 읽을 수 있도록 하기 위해서 불필요한 맥락을 추상화할 수 있다.

> 추상화란? <br>  
> 복잡한 구조, 원리, 설명을 간추리고 핵심만 말하는 것으로, 목적을 명확히 하여 복잡한 것은 숨기고 핵심만 드러내는 것이 추상화의 목적이다.
>
> > 예시
> >
> > -   추상화 수준이 높다 : 스위치 누른다.
> > -   추상화 수준이 낮다 : 접점(接點)을 이용하여 전자적 충격을 통해 논리회로로 이용한다.

📝 **코드 예시**

-   다음 `<LoginStartPage />` 컴포넌트는 사용자가 로그인되었는지 확인하고, 로그인이 된 경우 홈으로 이동시키는 로직을 가지고 있어요.

```jsx
function LoginStartPage() {
    useCheckLogin({
        onChecked: (status) => {
            if (status === 'LOGGED_IN') {
                location.href = '/home';
            }
        },
    });

    /* ... 로그인 관련 로직 ... */

    return <>{/* ... 로그인 관련 컴포넌트 ... */}</>;
}
```

-   예시 코드에서는 로그인이 되었는지 확인하고, 사용자를 홈으로 이동시키는 로직이 **추상화 없이 노출**되어 있어요. 그래서 `useCheckLogin`, `onChecked`, `status`, `"LOGGED_IN"`과 같은 변수나 값을 모두 읽어야 무슨 역할을 하는 코드인지 알 수 있어요.
-   이 코드와 더불어서, 실제로 로그인과 관련된 코드가 밑에 이어지는데요. 읽는 사람이 `LoginStartPage`가 무슨 역할을 하는지 알기 위해서 한 번에 이해해야 하는 맥락이 많아요.

이전에 클린코드에 대한 글을 읽은적이 있는데, 그 때 추상화에 대한 내용을 봤던 기억이 있다. 그 때는 지금보다도 더 전이라 무슨 얘기를 하는지 이해하기 어려웠는데 지금은 그래도 이해는 했다. 지나치게 자세히, 구체적인 것도 읽는 사람에게는 오히려 고려해야할 점이 많아 맥락을 파악하기가 더 힘들다는 것이다.

✏️ **개선해보기**

-   사용자가 로그인되었는지 확인하고 이동하는 로직을 HOC(Higher-Order Component) 나 Wrapper 컴포넌트로 분리하여, 코드를 읽는 사람이 한 번에 알아야 하는 맥락을 줄여요. 그래서 코드의 가독성을 높일 수 있어요.
-   또한, 분리된 컴포넌트 안에 있는 로직끼리 참조를 막음으로써, 코드 간의 불필요한 의존 관계가 생겨서 복잡해지는 것을 막을 수 있어요.

```jsx
// 옵션 A: Wrapper 컴포넌트 사용하기
function App() {
    return (
        <AuthGuard>
            <LoginStartPage />
        </AuthGuard>
    );
}

function AuthGuard({ children }) {
    const status = useCheckLoginStatus();

    useEffect(() => {
        if (status === 'LOGGED_IN') {
            location.href = '/home';
        }
    }, [status]);

    return status !== 'LOGGED_IN' ? children : null;
}

function LoginStartPage() {
    /* ... 로그인 관련 로직 ... */

    return <>{/* ... 로그인 관련 컴포넌트 ... */}</>;
}

// 옵션 B: HOC(Higher-Order Component) 사용하기
function LoginStartPage() {
    /* ... 로그인 관련 로직 ... */

    return <>{/* ... 로그인 관련 컴포넌트 ... */}</>;
}

export default withAuthGuard(LoginStartPage);

// HOC 정의
function withAuthGuard(WrappedComponent) {
    return function AuthGuard(props) {
        const status = useCheckLoginStatus();

        useEffect(() => {
            if (status === 'LOGGED_IN') {
                location.href = '/home';
            }
        }, [status]);

        return status !== 'LOGGED_IN' ? <WrappedComponent {...props} /> : null;
    };
}
```

💡 **변경하기 쉬운 코드 === 불필요한 맥락을 추상화하는 것**

가독성을 지키려면 코드가 한 번에 가지고 있는 맥락이 적어야 한다.

코드에서 구현 상세를 지나치게 드러내는 경우, 이 코드가 어떤 역할을 하는지 정확하게 파악하기 어렵다고 한다. 한 번에 6~7개 정도의 맥락을 한 번에 고려해 가면서 읽을 수 있도록, 보다 작은 단위로 추상화하는 것이 필요하다.

<br>

### 1-3. 매직 넘버에 이름 붙이기

> 매직 넘버(Magic Number)란? <br>
>
> -   정확한 뜻을 밝히지 않고 소스 코드 안에 직접 숫자 값을 넣는 것
> -   예를 들어, 찾을 수 없음(Not Found)을 나타내는 HTTP 상태 코드로 `404` 값을 바로 사용하는 것이나, 하루를 나타내는 `86400`초를 그대로 사용하는 것

📝 **코드 예시**

```jsx
async function onLikeClick() {
    await postLike(url);
    await delay(300);
    await refetchPostLike();
}
```

이 코드는 `delay` 함수에 전달된 `300`이라고 하는 값이 어떤 맥락으로 쓰였는지 알 수 없어요. 원래 코드를 작성한 개발자가 아니라면, 어떤 목적으로 300ms동안 기다리는지 알 수 없죠.

-   애니메이션이 완료될 때까지 기다리는 걸까?
-   좋아요 반영에 시간이 걸려서 기다리는 걸까?
-   테스트 코드였는데, 깜빡하고 안 지운 걸까?

하나의 코드를 여러 명의 개발자가 함께 수정하다 보면 의도를 정확히 알 수 없어서 코드가 원하지 않는 방향으로 수정될 수도 있어요.

✏️ **개선해보기**

-   숫자 `300`의 맥락을 정확하게 표시하기 위해서 상수 `ANIMATION_DELAY_MS`로 선언할 수 있어요.

```jsx
const ANIMATION_DELAY_MS = 300;

async function onLikeClick() {
    await postLike(url);
    await delay(ANIMATION_DELAY_MS);
    await refetchPostLike();
}
```

💡 **변경하기 쉬운 코드 === 맥락을 정확하게 표시하기 위해 매직 넘버에 이름을 붙이는 것**

이 예시 코드를 보니 나는 그동안 매직 넘버에 대해 깊이 생각해보지 않고 남발해온 것 같다.. 상수를 한번 더 선언하는 것이 불필요하고 효율적이지 않을 것이라고 생각하며 하드 코딩을 했던 것 같다. 하지만 협업이고, 가독성을 고려해야했다. _코드를 읽는 사람이 의도를 정확히 알 수 있게하는 것도 고려할 것_.

<br>

### 1-4. 시점 이동 줄이기

코드를 읽을 때 코드의 위아래를 왔다갔다 하면서 읽거나, 여러 파일이나 함수, 변수를 넘나들면서 읽는 것을 시점 이동이라고 해요. 시점이 여러 번 이동할수록 코드를 파악하는 데에 시간이 더 걸리고, 맥락을 파악하는 데에 어려움이 있을 수 있어요.

📝 **코드 예시**

다음 코드에서는 사용자의 권한에 따라서 버튼을 다르게 보여줘요.

-   사용자의 권한이 관리자(Admin)라면, `Invite`와 `View` 버튼을 보여줘요.
-   사용자의 권한이 보기 전용(Viewer)이라면, `Invite` 버튼은 비활성화하고, `View` 버튼을 보여줘요.

```jsx
function Page() {
    const user = useUser();
    const policy = getPolicyByRole(user.role);

    return (
        <div>
            <Button disabled={!policy.canInvite}>Invite</Button>
            <Button disabled={!policy.canView}>View</Button>
        </div>
    );
}

function getPolicyByRole(role) {
    const policy = POLICY_SET[role];

    return {
        canInvite: policy.includes('invite'),
        canView: policy.includes('view'),
    };
}

const POLICY_SET = {
    admin: ['invite', 'view'],
    viewer: ['view'],
};
```

이 코드에서 `Invite` 버튼이 비활성화된 이유를 이해하려고 한다면, `policy.canInvite` → `getPolicyByRole(user.role)` → `POLICY_SET` 순으로 코드를 위아래를 오가며 읽어야 해요. 이 과정에서 3번의 시점 이동이 발생해서, 코드를 읽는 사람이 맥락을 유지해 가며 읽기 어려워졌어요.

`POLICY_SET` 같은 추상화를 사용해서 권한에 따라 버튼 상태를 관리하는 것은 권한 체계가 복잡한 경우에는 유용할 수 있지만, 지금처럼 간단할 때는 오히려 읽는 사람이 코드를 이해하기 어렵게 만들어요.

✏️ **개선해보기**

**A. 조건을 펼쳐서 그대로 드러내기**

권한에 따른 조건을 요구사항 그대로 코드에 드러내는 방법이에요. 이렇게 하면 `Invite` 버튼이 비활성화되는 때를 코드에서 바로 확인할 수 있어요. 코드를 위에서 아래로만 읽으면 한눈에 권한을 다루는 로직을 파악할 수 있어요.

```jsx
function Page() {
    const user = useUser();

    switch (user.role) {
        case 'admin':
            return (
                <div>
                    <Button disabled={false}>Invite</Button>
                    <Button disabled={false}>View</Button>
                </div>
            );
        case 'viewer':
            return (
                <div>
                    <Button disabled={true}>Invite</Button>
                    <Button disabled={false}>View</Button>
                </div>
            );
        default:
            return null;
    }
}
```

**B. 조건을 한눈에 볼 수 있는 객체로 만들기**

권한을 다루는 로직을 컴포넌트 안에서 객체로 관리해서, 여러 차례의 시점 이동 없이 한눈에 조건을 파악할 수 있게 수정할 수 있어요. `canInvite`와 `canView`의 조건을 `Page` 컴포넌트만 보면 확인할 수 있어요.

```jsx
function Page() {
    const user = useUser();
    const policy = {
        admin: { canInvite: true, canView: true },
        viewer: { canInvite: false, canView: true },
    }[user.role];

    return (
        <div>
            <Button disabled={!policy.canInvite}>Invite</Button>
            <Button disabled={!policy.canView}>View</Button>
        </div>
    );
}
```

💡 **변경하기 쉬운 코드 === 코드를 위에서 아래로, 하나의 함수나 파일에서 읽을 수 있도록 시점 이동을 줄이는 것**

<br>

### 1-5. 삼항 연산자 단순하게 하기

삼항 연산자를 복잡하게 사용하면 조건의 구조가 명확하게 보이지 않아서 코드를 읽기 어려울 수 있어요.

📝 **코드 예시**

다음 코드는 `A조건`과 `B조건`에 따라서 `"BOTH"`, `"A"`, `"B"` 또는 `"NONE"` 중 하나를 `status`에 지정하는 코드예요.

```jsx
const status = A조건 && B조건 ? 'BOTH' : A조건 || B조건 ? (A조건 ? 'A' : 'B') : 'NONE';
```

이 코드는 여러 삼항 연산자가 중첩되어 사용되어서, 정확하게 어떤 조건으로 값이 계산되는지 한눈에 파악하기 어려워요.

✏️ **개선해보기**

다음과 같이 조건을 `if` 문으로 풀어서 사용하면 보다 명확하고 간단하게 조건을 드러낼 수 있어요.

```jsx
const status = (() => {
    if (A조건 && B조건) return 'BOTH';
    if (A조건) return 'A';
    if (B조건) return 'B';
    return 'NONE';
})();
```

💡 **변경하기 쉬운 코드 === 복잡한 삼항 연산자는 단순하게 조건을 드러내어 한눈에 파악할수 있게 하는 것**

생각해보니 조건이 어디서 끊기는지도 한눈에 파악하기 어려운 코드들이 많았던 것 같다. 습관처럼 삼항 연산자를 쓰고 있지는 않았는지 다시 한번 돌아보게 된다.😂

<br>
