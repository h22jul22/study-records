토스에서 좋은 프론트엔드 코드의 기준에 대해서 소개하는 [Frontend Fundamentals](https://frontend-fundamentals.com/)가 오픈 소스로 공개되었다.

> 이런 분들에게 추천해요

-   🦨 코드에 대해서 고민되는데 **논리적으로 설명하기 어려운 개발자**
-   👀 **나쁜 코드를 빠르게 감지**하고 개선하는 방법을 공부하고 싶은 개발자
-   🤓 코드 리뷰 등에서 누가 전달해준 링크를 타고 들어와 "내 코드가 이랬구나"를 **객관적 시각으로 인지**하게 될 개발자
-   👥 **팀과 함께** 공통의 코딩 스타일과 코드 품질의 기준을 세워보고 싶은 개발자

나는 그저 아직 학습중인 예비 프론트엔드 개발자로서, 나에게는 좋은 프론트엔드 코드는 어떤건지에 대한 몇가지의 방향성에 대해 고민할 수 있게 기준을 정리해주는 가이드가 될 것 같아 너무나도 감사한 정보 공유이다.

물론 지금 모든 내용을 다 이해하고 반영할 수 있는 부분인지는 모르겠지만, 내용을 살펴보면서 학습하고 기록하고자 한다. 앞으로 코드를 작성하고 리팩토링하면서 어떤 기준으로 좋은 코드를 위해 고민했는가에 대한 가이드가 되지 않을까싶다.

정리한 내용은 평소 생각해보지 못했던 부분이나, 새롭게 알게된 내용 등을 위주로 작성하였다.

> 🗣️ "좋은 프론트엔드 코드는 **변경하기 쉬운** 코드예요."

좋은 코드란 변경하기 쉬운 코드이다. 즉 좋은 코드를 위한 설명으로 변경하기 쉬운 코드에 대한 전략을 소개하고 있다.

그렇다면 어떤 코드가 변경하기 쉬운가?

코드가 변경하기 쉬운지는 4가지 기준(가독성, 예측가능성, 응집도, 결합도)으로 판단할 수 있다.

## 1. 가독성

### 1-1. 같이 실행되지 않는 코드 분리하기

동시에 실행되지 않는 코드가 하나의 함수 또는 컴포넌트에 있으면 코드를 읽는 사람이 한 번에 고려해야 하는 맥락이 많고, 동시에 실행되지 않는 코드가 교차되어서 나타나서 코드를 이해할 때 부담을 준다.

📝 **코드 예시**

-   사용자의 권한이 보기 전용(`"viewer"`)이면, 초대 버튼은 비활성화되어 있고, 애니메이션도 재생하지 않아요.
-   사용자가 일반 사용자이면, 초대 버튼을 사용할 수 있고, 애니메이션도 재생해요.

```jsx
function SubmitButton() {
    const isViewer = useRole() === 'viewer';

    useEffect(() => {
        if (isViewer) {
            return;
        }
        showButtonAnimation();
    }, [isViewer]);

    return isViewer ? (
        <TextButton disabled>Submit</TextButton>
    ) : (
        <Button type='submit'>Submit</Button>
    );
}
```

나는 예시 코드를 보고 어떤 점이 문제인지 인지하지 못했다..
왜냐하면 나는 이렇게 코드를 짜왔기 때문이다. 😂

✏️ **개선해보기**

-   `<SubmitButton />` 코드 곳곳에 있던 분기가 단 하나로 합쳐지면서, 분기가 줄어들었어요.
-   `<ViewerSubmitButton />`과 `<AdminSubmitButton />` 에서는 하나의 분기만 관리하기 때문에, 코드를 읽는 사람이 한 번에 고려해야 할 맥락이 적어요.

```jsx
function SubmitButton() {
    const isViewer = useRole() === 'viewer';

    return isViewer ? <ViewerSubmitButton /> : <AdminSubmitButton />;
}

function ViewerSubmitButton() {
    return <TextButton disabled>Submit</TextButton>;
}

function AdminSubmitButton() {
    useEffect(() => {
        showAnimation();
    }, []);

    return <Button type='submit'>Submit</Button>;
}
```

💡 **변경하기 쉬운 코드 === 코드를 읽는 사람이 한 번에 고려해야 하는 맥락이 적은 것**

때문에 같이 실행되지 않는 코드는 분리하여 분기를 줄이고, 어떤 역할을 하는지 이해하기 쉽게 맥락을 줄여보자.

### 1-2. 구현 상세 추상화하기

한 사람이 코드를 읽을 때 동시에 고려할 수 있는 총 맥락의 숫자는 제한되어 있다고 한다. 내 코드를 읽는 사람들이 코드를 쉽게 읽을 수 있도록 하기 위해서 불필요한 맥락을 추상화할 수 있다.

> 추상화란? <br>  
> 복잡한 구조, 원리, 설명을 간추리고 핵심만 말하는 것으로, 목적을 명확히 하여 복잡한 것은 숨기고 핵심만 드러내는 것이 추상화의 목적이다.
>
> > 예시
> >
> > -   추상화 수준이 높다 : 스위치 누른다.
> > -   추상화 수준이 낮다 : 접점(接點)을 이용하여 전자적 충격을 통해 논리회로로 이용한다.

📝 **코드 예시**

-   다음 `<LoginStartPage />` 컴포넌트는 사용자가 로그인되었는지 확인하고, 로그인이 된 경우 홈으로 이동시키는 로직을 가지고 있어요.

```jsx
function LoginStartPage() {
    useCheckLogin({
        onChecked: (status) => {
            if (status === 'LOGGED_IN') {
                location.href = '/home';
            }
        },
    });

    /* ... 로그인 관련 로직 ... */

    return <>{/* ... 로그인 관련 컴포넌트 ... */}</>;
}
```

-   예시 코드에서는 로그인이 되었는지 확인하고, 사용자를 홈으로 이동시키는 로직이 **추상화 없이 노출**되어 있어요. 그래서 `useCheckLogin`, `onChecked`, `status`, `"LOGGED_IN"`과 같은 변수나 값을 모두 읽어야 무슨 역할을 하는 코드인지 알 수 있어요.
-   이 코드와 더불어서, 실제로 로그인과 관련된 코드가 밑에 이어지는데요. 읽는 사람이 `LoginStartPage`가 무슨 역할을 하는지 알기 위해서 한 번에 이해해야 하는 맥락이 많아요.

이전에 클린코드에 대한 글을 읽은적이 있는데, 그 때 추상화에 대한 내용을 봤던 기억이 있다. 그 때는 지금보다도 더 전이라 무슨 얘기를 하는지 이해하기 어려웠는데 지금은 그래도 이해는 했다. 지나치게 자세히, 구체적인 것도 읽는 사람에게는 오히려 고려해야할 점이 많아 맥락을 파악하기가 더 힘들다는 것이다.

✏️ **개선해보기**

-   사용자가 로그인되었는지 확인하고 이동하는 로직을 HOC(Higher-Order Component) 나 Wrapper 컴포넌트로 분리하여, 코드를 읽는 사람이 한 번에 알아야 하는 맥락을 줄여요. 그래서 코드의 가독성을 높일 수 있어요.
-   또한, 분리된 컴포넌트 안에 있는 로직끼리 참조를 막음으로써, 코드 간의 불필요한 의존 관계가 생겨서 복잡해지는 것을 막을 수 있어요.

```jsx
// 옵션 A: Wrapper 컴포넌트 사용하기
function App() {
    return (
        <AuthGuard>
            <LoginStartPage />
        </AuthGuard>
    );
}

function AuthGuard({ children }) {
    const status = useCheckLoginStatus();

    useEffect(() => {
        if (status === 'LOGGED_IN') {
            location.href = '/home';
        }
    }, [status]);

    return status !== 'LOGGED_IN' ? children : null;
}

function LoginStartPage() {
    /* ... 로그인 관련 로직 ... */

    return <>{/* ... 로그인 관련 컴포넌트 ... */}</>;
}

// 옵션 B: HOC(Higher-Order Component) 사용하기
function LoginStartPage() {
    /* ... 로그인 관련 로직 ... */

    return <>{/* ... 로그인 관련 컴포넌트 ... */}</>;
}

export default withAuthGuard(LoginStartPage);

// HOC 정의
function withAuthGuard(WrappedComponent) {
    return function AuthGuard(props) {
        const status = useCheckLoginStatus();

        useEffect(() => {
            if (status === 'LOGGED_IN') {
                location.href = '/home';
            }
        }, [status]);

        return status !== 'LOGGED_IN' ? <WrappedComponent {...props} /> : null;
    };
}
```

💡 **변경하기 쉬운 코드 === 불필요한 맥락을 추상화하는 것**

가독성을 지키려면 코드가 한 번에 가지고 있는 맥락이 적어야 한다.

코드에서 구현 상세를 지나치게 드러내는 경우, 이 코드가 어떤 역할을 하는지 정확하게 파악하기 어렵다고 한다. 한 번에 6~7개 정도의 맥락을 한 번에 고려해 가면서 읽을 수 있도록, 보다 작은 단위로 추상화하는 것이 필요하다.
